// This file was GENERATED by command:
//     pump.py closure.h.pump
// DO NOT EDIT BY HAND!!!

/* Copyright (c) 2012-2017, Bin Wei <bin@vip.qq.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * The names of its contributors may not be used to endorse or
 * promote products derived from this software without specific prior
 * written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#ifndef CCBASE_CLOSURE_H_
#define CCBASE_CLOSURE_H_

#include <assert.h>
#include <atomic>
#include <utility>
#include "ccbase/common.h"

namespace ccb {

// Closure base class
class ClosureBase {
 public:
  virtual ~ClosureBase() {}
  virtual bool IsPermanent() const = 0;
};

// Closure template
template <typename Signature>
class Closure : public ClosureBase {
 public:
};

template <typename Signature>
class ClosureFunc {
 public:
};

// Closure specified for 0 arguments
template <
  typename R >
class Closure<R()> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run() = 0;
  virtual Closure<R()>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R()>;
};

// forward declaraton for ClosureFunc
template <typename R, typename F> Closure<R()>* NewPermanentClosure(F&&);

template <
  typename R >
class ClosureFunc<R()> {
 public:
  typedef Closure<R()> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept :
      ClosureFunc(NewPermanentClosure<R>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()() const {
    return p_->Run();
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 1 arguments
template <
  typename R , typename A1>
class Closure<R(A1)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1) = 0;
  virtual Closure<R(A1)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1,
    typename F> Closure<R(A1)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1>
class ClosureFunc<R(A1)> {
 public:
  typedef Closure<R(A1)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R,
      A1>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1) const {
    return p_->Run(a1);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 2 arguments
template <
  typename R , typename A1, typename A2>
class Closure<R(A1, A2)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2) = 0;
  virtual Closure<R(A1, A2)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1, A2)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename F> Closure<R(A1,
    A2)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2>
class ClosureFunc<R(A1, A2)> {
 public:
  typedef Closure<R(A1, A2)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1,
      A2>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1, A2 a2) const {
    return p_->Run(a1, a2);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 3 arguments
template <
  typename R , typename A1, typename A2, typename A3>
class Closure<R(A1, A2, A3)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3) = 0;
  virtual Closure<R(A1, A2, A3)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1, A2, A3)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3,
    typename F> Closure<R(A1, A2, A3)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3>
class ClosureFunc<R(A1, A2, A3)> {
 public:
  typedef Closure<R(A1, A2, A3)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2,
      A3>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1, A2 a2, A3 a3) const {
    return p_->Run(a1, a2, a3);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 4 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4>
class Closure<R(A1, A2, A3, A4)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4) = 0;
  virtual Closure<R(A1, A2, A3, A4)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1, A2, A3, A4)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename F> Closure<R(A1, A2, A3, A4)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4>
class ClosureFunc<R(A1, A2, A3, A4)> {
 public:
  typedef Closure<R(A1, A2, A3, A4)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4) const {
    return p_->Run(a1, a2, a3, a4);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 5 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5>
class Closure<R(A1, A2, A3, A4, A5)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) = 0;
  virtual Closure<R(A1, A2, A3, A4, A5)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1, A2, A3, A4, A5)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename F> Closure<R(A1, A2, A3, A4,
    A5)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5>
class ClosureFunc<R(A1, A2, A3, A4, A5)> {
 public:
  typedef Closure<R(A1, A2, A3, A4, A5)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4, A5>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const {
    return p_->Run(a1, a2, a3, a4, a5);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure specified for 6 arguments
template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5,
      typename A6>
class Closure<R(A1, A2, A3, A4, A5, A6)> : public ClosureBase {
 public:
  Closure() : ref_count_(1) {}
  Closure(const Closure& c) : ref_count_(1) {}
  virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) = 0;
  virtual Closure<R(A1, A2, A3, A4, A5, A6)>* Clone() = 0;
 private:
  void AddRef() {
    assert(ref_count_ > 0);
    ref_count_.fetch_add(1);
  }
  void DelRef() {
    assert(IsPermanent());
    if (ref_count_.fetch_sub(1) == 1) {
      delete this;
    }
  }
  std::atomic<int64_t> ref_count_;
  friend class ClosureFunc<R(A1, A2, A3, A4, A5, A6)>;
};

// forward declaraton for ClosureFunc
template <typename R, typename A1, typename A2, typename A3, typename A4,
    typename A5, typename A6, typename F> Closure<R(A1, A2, A3, A4, A5,
    A6)>* NewPermanentClosure(F&&);

template <
  typename R , typename A1, typename A2, typename A3, typename A4, typename A5,
      typename A6>
class ClosureFunc<R(A1, A2, A3, A4, A5, A6)> {
 public:
  typedef Closure<R(A1, A2, A3, A4, A5, A6)> ClosureType;
  ClosureFunc() : p_(nullptr) {}
  ClosureFunc(std::nullptr_t) : p_(nullptr) {}
  template <class F,
      typename = typename std::enable_if<!std::is_same<typename std::decay<F>::type,
      ClosureFunc>::value>::type>
  ClosureFunc(F&& f) noexcept : ClosureFunc(NewPermanentClosure<R, A1, A2, A3,
      A4, A5, A6>(std::forward<F>(f))) {}
  explicit ClosureFunc(ClosureType* p) noexcept : p_(p) {
    assert(!p || p->IsPermanent());
  }
  ClosureFunc(const ClosureFunc& c) noexcept : ClosureFunc(c.share()) {}
  ClosureFunc(ClosureFunc&& c) noexcept : p_(c.release()) {}
  ~ClosureFunc() {
    if (p_) p_->DelRef();
  }
  operator bool() const {
    return static_cast<bool>(p_);
  }
  R operator()(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const {
    return p_->Run(a1, a2, a3, a4, a5, a6);
  }
  void swap(ClosureFunc& c) {
    std::swap(p_, c.p_);
  }
  void reset(ClosureType* p = nullptr) {
    ClosureFunc(p).swap(*this);
  }
  ClosureFunc& operator=(const ClosureFunc& c) {
    ClosureFunc(c).swap(*this);
    return *this;
  }
  ClosureFunc& operator=(ClosureFunc&& c) {
    ClosureFunc(std::move(c)).swap(*this);
    return *this;
  }
 private:
  ClosureType* get() const {
    return p_;
  }
  ClosureType* share() const {
    if (p_) p_->AddRef();
    return p_;
  }
  ClosureType* release() {
    ClosureType* p = get();
    p_ = nullptr;
    return p;
  }
  ClosureType* p_;
};

// Closure deleter
template <bool Enabled, typename T>
class ConditionalAutoDeleter {
 public:
  explicit ConditionalAutoDeleter(T* p)
      : p_(p) {
  }
  ~ConditionalAutoDeleter() {
    if (Enabled)
      delete p_;
  }
 private:
  ConditionalAutoDeleter(const ConditionalAutoDeleter&);
  ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
 private:
  T* p_;
};

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass >
class MethodClosure_Arg0_Bind0 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)();
  MethodClosure_Arg0_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind0> self_deleter(this);
    return (object_->*method_)();
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)()) {
  return new MethodClosure_Arg0_Bind0<false, R, Class, MethodClass>(
    object, method);
}

template <typename R, typename Class, typename MethodClass>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)()) {
  return new MethodClosure_Arg0_Bind0<true, R, Class, MethodClass>(
    object, method);
}

template <typename R, typename Class, typename MethodClass>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)()) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R>
class FunctionClosure_Arg0_Bind0 : public Closure<R()> {
 public:
  typedef R(*FunctionType)();
  FunctionClosure_Arg0_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind0> self_deleter(this);
    return function_();
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R>
Closure<R()>*
NewClosure(R(*function)()) {
  return new FunctionClosure_Arg0_Bind0<false, R>(function);
}

template <typename R>
Closure<R()>*
NewPermanentClosure(R(*function)()) {
  return new FunctionClosure_Arg0_Bind0<true, R>(function);
}

template <typename R>
ClosureFunc<R()>
BindClosure(R(*function)()) {
  return ClosureFunc<R()>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R>
class FunctorClosure_Arg0_Bind0 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg0_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind0> self_deleter(this);
    return functor_();
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename F>
Closure<R()>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg0_Bind0<false, typename std::decay<F>::type, R>(
    std::forward<F>(functor));
}

template <typename R, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg0_Bind0<true, typename std::decay<F>::type, R>(
    std::forward<F>(functor));
}

template <typename R, typename F>
ClosureFunc<R()>
BindClosure(F&& functor) {
  return ClosureFunc<R()>(NewPermanentClosure<R>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1 , typename PreArg1>
class MethodClosure_Arg0_Bind1 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1);
  MethodClosure_Arg0_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1), PreArg1 pa1) {
  return new MethodClosure_Arg0_Bind1<false, R, Class, MethodClass, Arg1,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1), PreArg1 pa1) {
  return new MethodClosure_Arg0_Bind1<true, R, Class, MethodClass, Arg1,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename PreArg1>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1), PreArg1 pa1) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename PreArg1>
class FunctionClosure_Arg0_Bind1 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1);
  FunctionClosure_Arg0_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind1> self_deleter(this);
    return function_(pa_1_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename PreArg1>
Closure<R()>*
NewClosure(R(*function)(Arg1), PreArg1 pa1) {
  return new FunctionClosure_Arg0_Bind1<false, R, Arg1, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename PreArg1>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1), PreArg1 pa1) {
  return new FunctionClosure_Arg0_Bind1<true, R, Arg1, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename PreArg1>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1), PreArg1 pa1) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename PreArg1>
class FunctorClosure_Arg0_Bind1 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg0_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind1> self_deleter(this);
    return functor_(pa_1_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename PreArg1, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg0_Bind1<false, typename std::decay<F>::type, R,
      Arg1, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename PreArg1, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg0_Bind1<true, typename std::decay<F>::type, R,
      Arg1, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename PreArg1, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1,
      typename PreArg2>
class MethodClosure_Arg0_Bind2 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2);
  MethodClosure_Arg0_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2), PreArg1 pa1,
    PreArg2 pa2) {
  return new MethodClosure_Arg0_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg0_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1, typename PreArg2>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg0_Bind2 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2);
  FunctionClosure_Arg0_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
Closure<R()>*
NewClosure(R(*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg0_Bind2<false, R, Arg1, Arg2, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg0_Bind2<true, R, Arg1, Arg2, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg0_Bind2 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg0_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg0_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg0_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename PreArg2, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1, Arg2, PreArg1,
      PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg0_Bind3 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3);
  MethodClosure_Arg0_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg0_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg0_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctionClosure_Arg0_Bind3 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3);
  FunctionClosure_Arg0_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R()>*
NewClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg0_Bind3<false, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg0_Bind3<true, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctorClosure_Arg0_Bind3 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg0_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg0_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg0_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2, PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class MethodClosure_Arg0_Bind4 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
  MethodClosure_Arg0_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg0_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg0_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg0_Bind4 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4);
  FunctionClosure_Arg0_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R()>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg0_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg0_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg0_Bind4 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg0_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg0_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg0_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3, PreArg4>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg0_Bind5 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg0_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg0_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg0_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctionClosure_Arg0_Bind5 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg0_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R()>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg0_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2, pa3,
      pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg0_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2, pa3,
      pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctorClosure_Arg0_Bind5 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg0_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg0_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg0_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(std::forward<F>(functor),
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class MethodClosure_Arg0_Bind6 : public Closure<R()> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg0_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg0_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_);
  }
  virtual Closure<R()>* Clone() {
    return new MethodClosure_Arg0_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R()>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new MethodClosure_Arg0_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R()>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg0_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R()>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R ()>(NewPermanentClosure(object, method, pa1, pa2, pa3,
      pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg0_Bind6 : public Closure<R()> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg0_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg0_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctionClosure_Arg0_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R()>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg0_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(function,
      pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R()>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg0_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(function,
      pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R()>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R()>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg0_Bind6 : public Closure<R()> {
public:
  explicit FunctorClosure_Arg0_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg0_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run() {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg0_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_);
  }
  virtual Closure<R()>* Clone() {
    return new FunctorClosure_Arg0_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R()>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg0_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R()>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg0_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
ClosureFunc<R()>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R()>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1 >
class MethodClosure_Arg1_Bind0 : public Closure<R(Arg1)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1);
  MethodClosure_Arg1_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind0> self_deleter(this);
    return (object_->*method_)(arg1);
  }
  virtual Closure<R(Arg1)>* Clone() {
    return new MethodClosure_Arg1_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R(Arg1)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1)) {
  return new MethodClosure_Arg1_Bind0<false, R, Class, MethodClass, Arg1>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R(Arg1)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1)) {
  return new MethodClosure_Arg1_Bind0<true, R, Class, MethodClass, Arg1>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1>
ClosureFunc<R(Arg1)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1)) {
  return ClosureFunc<R (Arg1)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1>
class FunctionClosure_Arg1_Bind0 : public Closure<R(Arg1)> {
 public:
  typedef R(*FunctionType)(Arg1);
  FunctionClosure_Arg1_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind0> self_deleter(this);
    return function_(arg1);
  }
  virtual Closure<R(Arg1)>* Clone() {
    return new FunctionClosure_Arg1_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1>
Closure<R(Arg1)>*
NewClosure(R(*function)(Arg1)) {
  return new FunctionClosure_Arg1_Bind0<false, R, Arg1>(function);
}

template <typename R, typename Arg1>
Closure<R(Arg1)>*
NewPermanentClosure(R(*function)(Arg1)) {
  return new FunctionClosure_Arg1_Bind0<true, R, Arg1>(function);
}

template <typename R, typename Arg1>
ClosureFunc<R(Arg1)>
BindClosure(R(*function)(Arg1)) {
  return ClosureFunc<R(Arg1)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1>
class FunctorClosure_Arg1_Bind0 : public Closure<R(Arg1)> {
public:
  explicit FunctorClosure_Arg1_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg1_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind0> self_deleter(this);
    return functor_(arg1);
  }
  virtual Closure<R(Arg1)>* Clone() {
    return new FunctorClosure_Arg1_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename F>
Closure<R(Arg1)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg1_Bind0<false, typename std::decay<F>::type, R,
      Arg1>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename F>
Closure<R(Arg1)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg1_Bind0<true, typename std::decay<F>::type, R,
      Arg1>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename F>
ClosureFunc<R(Arg1)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1)>(NewPermanentClosure<R,
      Arg1>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1>
class MethodClosure_Arg1_Bind1 : public Closure<R(Arg2)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2);
  MethodClosure_Arg1_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2);
  }
  virtual Closure<R(Arg2)>* Clone() {
    return new MethodClosure_Arg1_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
Closure<R(Arg2)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2), PreArg1 pa1) {
  return new MethodClosure_Arg1_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
Closure<R(Arg2)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2),
    PreArg1 pa1) {
  return new MethodClosure_Arg1_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename PreArg1>
ClosureFunc<R(Arg2)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2), PreArg1 pa1) {
  return ClosureFunc<R (Arg2)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename PreArg1>
class FunctionClosure_Arg1_Bind1 : public Closure<R(Arg2)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2);
  FunctionClosure_Arg1_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind1> self_deleter(this);
    return function_(pa_1_, arg2);
  }
  virtual Closure<R(Arg2)>* Clone() {
    return new FunctionClosure_Arg1_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R(Arg2)>*
NewClosure(R(*function)(Arg1, Arg2), PreArg1 pa1) {
  return new FunctionClosure_Arg1_Bind1<false, R, Arg1, Arg2,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R(Arg2)>*
NewPermanentClosure(R(*function)(Arg1, Arg2), PreArg1 pa1) {
  return new FunctionClosure_Arg1_Bind1<true, R, Arg1, Arg2, PreArg1>(function,
      pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
ClosureFunc<R(Arg2)>
BindClosure(R(*function)(Arg1, Arg2), PreArg1 pa1) {
  return ClosureFunc<R(Arg2)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename PreArg1>
class FunctorClosure_Arg1_Bind1 : public Closure<R(Arg2)> {
public:
  explicit FunctorClosure_Arg1_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg1_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2);
  }
  virtual Closure<R(Arg2)>* Clone() {
    return new FunctorClosure_Arg1_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
Closure<R(Arg2)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg1_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
Closure<R(Arg2)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg1_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
    typename F>
ClosureFunc<R(Arg2)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2)>(NewPermanentClosure<R, Arg1, Arg2,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1, typename PreArg2>
class MethodClosure_Arg1_Bind2 : public Closure<R(Arg3)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3);
  MethodClosure_Arg1_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3);
  }
  virtual Closure<R(Arg3)>* Clone() {
    return new MethodClosure_Arg1_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R(Arg3)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg1_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R(Arg3)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg1_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2>
class FunctionClosure_Arg1_Bind2 : public Closure<R(Arg3)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3);
  FunctionClosure_Arg1_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3);
  }
  virtual Closure<R(Arg3)>* Clone() {
    return new FunctionClosure_Arg1_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg1_Bind2<false, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg1_Bind2<true, R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3)>
BindClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
      typename PreArg2>
class FunctorClosure_Arg1_Bind2 : public Closure<R(Arg3)> {
public:
  explicit FunctorClosure_Arg1_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg1_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3);
  }
  virtual Closure<R(Arg3)>* Clone() {
    return new FunctorClosure_Arg1_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg1_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg1_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R(Arg3)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, PreArg1,
      PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg1_Bind3 : public Closure<R(Arg4)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
  MethodClosure_Arg1_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4);
  }
  virtual Closure<R(Arg4)>* Clone() {
    return new MethodClosure_Arg1_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg1_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg1_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg1_Bind3 : public Closure<R(Arg4)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4);
  FunctionClosure_Arg1_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4);
  }
  virtual Closure<R(Arg4)>* Clone() {
    return new FunctionClosure_Arg1_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new FunctionClosure_Arg1_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg1_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return ClosureFunc<R(Arg4)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg1_Bind3 : public Closure<R(Arg4)> {
public:
  explicit FunctorClosure_Arg1_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg1_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4);
  }
  virtual Closure<R(Arg4)>* Clone() {
    return new FunctorClosure_Arg1_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R(Arg4)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg1_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R(Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg1_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
ClosureFunc<R(Arg4)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class MethodClosure_Arg1_Bind4 : public Closure<R(Arg5)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg1_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5);
  }
  virtual Closure<R(Arg5)>* Clone() {
    return new MethodClosure_Arg1_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg1_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg1_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctionClosure_Arg1_Bind4 : public Closure<R(Arg5)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg1_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5);
  }
  virtual Closure<R(Arg5)>* Clone() {
    return new FunctionClosure_Arg1_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg1_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg1_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5)>(NewPermanentClosure(function, pa1, pa2, pa3,
      pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctorClosure_Arg1_Bind4 : public Closure<R(Arg5)> {
public:
  explicit FunctorClosure_Arg1_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg1_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5);
  }
  virtual Closure<R(Arg5)>* Clone() {
    return new FunctorClosure_Arg1_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg1_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg1_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R(Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(std::forward<F>(functor), pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg1_Bind5 : public Closure<R(Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg1_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6);
  }
  virtual Closure<R(Arg6)>* Clone() {
    return new MethodClosure_Arg1_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg1_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg1_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R(Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg1_Bind5 : public Closure<R(Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg1_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6);
  }
  virtual Closure<R(Arg6)>* Clone() {
    return new FunctionClosure_Arg1_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg1_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
      pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg1_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
      pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R(Arg6)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg1_Bind5 : public Closure<R(Arg6)> {
public:
  explicit FunctorClosure_Arg1_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg1_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6);
  }
  virtual Closure<R(Arg6)>* Clone() {
    return new FunctorClosure_Arg1_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R(Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg1_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R(Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg1_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
ClosureFunc<R(Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class MethodClosure_Arg1_Bind6 : public Closure<R(Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg1_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg1_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7);
  }
  virtual Closure<R(Arg7)>* Clone() {
    return new MethodClosure_Arg1_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg1_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg1_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7)>(NewPermanentClosure(object, method, pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctionClosure_Arg1_Bind6 : public Closure<R(Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg1_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg1_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7);
  }
  virtual Closure<R(Arg7)>* Clone() {
    return new FunctionClosure_Arg1_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg1_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg1_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R(Arg7)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4,
      pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctorClosure_Arg1_Bind6 : public Closure<R(Arg7)> {
public:
  explicit FunctorClosure_Arg1_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg1_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg1_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7);
  }
  virtual Closure<R(Arg7)>* Clone() {
    return new FunctorClosure_Arg1_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg1_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg1_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R(Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4,
      Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2 >
class MethodClosure_Arg2_Bind0 : public Closure<R(Arg1, Arg2)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2);
  MethodClosure_Arg2_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2);
  }
  virtual Closure<R(Arg1, Arg2)>* Clone() {
    return new MethodClosure_Arg2_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
Closure<R(Arg1, Arg2)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2)) {
  return new MethodClosure_Arg2_Bind0<false, R, Class, MethodClass, Arg1, Arg2>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
Closure<R(Arg1, Arg2)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2)) {
  return new MethodClosure_Arg2_Bind0<true, R, Class, MethodClass, Arg1, Arg2>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2>
ClosureFunc<R(Arg1, Arg2)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2)) {
  return ClosureFunc<R (Arg1, Arg2)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2>
class FunctionClosure_Arg2_Bind0 : public Closure<R(Arg1, Arg2)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2);
  FunctionClosure_Arg2_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind0> self_deleter(this);
    return function_(arg1, arg2);
  }
  virtual Closure<R(Arg1, Arg2)>* Clone() {
    return new FunctionClosure_Arg2_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2>
Closure<R(Arg1, Arg2)>*
NewClosure(R(*function)(Arg1, Arg2)) {
  return new FunctionClosure_Arg2_Bind0<false, R, Arg1, Arg2>(function);
}

template <typename R, typename Arg1, typename Arg2>
Closure<R(Arg1, Arg2)>*
NewPermanentClosure(R(*function)(Arg1, Arg2)) {
  return new FunctionClosure_Arg2_Bind0<true, R, Arg1, Arg2>(function);
}

template <typename R, typename Arg1, typename Arg2>
ClosureFunc<R(Arg1, Arg2)>
BindClosure(R(*function)(Arg1, Arg2)) {
  return ClosureFunc<R(Arg1, Arg2)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2>
class FunctorClosure_Arg2_Bind0 : public Closure<R(Arg1, Arg2)> {
public:
  explicit FunctorClosure_Arg2_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg2_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind0> self_deleter(this);
    return functor_(arg1, arg2);
  }
  virtual Closure<R(Arg1, Arg2)>* Clone() {
    return new FunctorClosure_Arg2_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename F>
Closure<R(Arg1, Arg2)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg2_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename F>
Closure<R(Arg1, Arg2)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg2_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename F>
ClosureFunc<R(Arg1, Arg2)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1, Arg2)>(NewPermanentClosure<R, Arg1,
      Arg2>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
      typename PreArg1>
class MethodClosure_Arg2_Bind1 : public Closure<R(Arg2, Arg3)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3);
  MethodClosure_Arg2_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2, arg3);
  }
  virtual Closure<R(Arg2, Arg3)>* Clone() {
    return new MethodClosure_Arg2_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
Closure<R(Arg2, Arg3)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return new MethodClosure_Arg2_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
Closure<R(Arg2, Arg3)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return new MethodClosure_Arg2_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename PreArg1>
ClosureFunc<R(Arg2, Arg3)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3),
    PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1>
class FunctionClosure_Arg2_Bind1 : public Closure<R(Arg2, Arg3)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3);
  FunctionClosure_Arg2_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind1> self_deleter(this);
    return function_(pa_1_, arg2, arg3);
  }
  virtual Closure<R(Arg2, Arg3)>* Clone() {
    return new FunctionClosure_Arg2_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
Closure<R(Arg2, Arg3)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return new FunctionClosure_Arg2_Bind1<false, R, Arg1, Arg2, Arg3,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
Closure<R(Arg2, Arg3)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return new FunctionClosure_Arg2_Bind1<true, R, Arg1, Arg2, Arg3,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1>
ClosureFunc<R(Arg2, Arg3)>
BindClosure(R(*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1>
class FunctorClosure_Arg2_Bind1 : public Closure<R(Arg2, Arg3)> {
public:
  explicit FunctorClosure_Arg2_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg2_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2, arg3);
  }
  virtual Closure<R(Arg2, Arg3)>* Clone() {
    return new FunctorClosure_Arg2_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
Closure<R(Arg2, Arg3)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg2_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
Closure<R(Arg2, Arg3)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg2_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename PreArg1, typename F>
ClosureFunc<R(Arg2, Arg3)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg2_Bind2 : public Closure<R(Arg3, Arg4)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
  MethodClosure_Arg2_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3, arg4);
  }
  virtual Closure<R(Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg2_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
Closure<R(Arg3, Arg4)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg2_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
Closure<R(Arg3, Arg4)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg2_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
    typename PreArg2>
ClosureFunc<R(Arg3, Arg4)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4)>(NewPermanentClosure(object, method, pa1,
      pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2>
class FunctionClosure_Arg2_Bind2 : public Closure<R(Arg3, Arg4)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4);
  FunctionClosure_Arg2_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3, arg4);
  }
  virtual Closure<R(Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg2_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg2_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg2_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1, typename PreArg2>
class FunctorClosure_Arg2_Bind2 : public Closure<R(Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg2_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg2_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3, arg4);
  }
  virtual Closure<R(Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg2_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg2_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg2_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R(Arg3, Arg4)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
      typename PreArg3>
class MethodClosure_Arg2_Bind3 : public Closure<R(Arg4, Arg5)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg2_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4, arg5);
  }
  virtual Closure<R(Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg2_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg2_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg2_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg2_Bind3 : public Closure<R(Arg4, Arg5)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg2_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4, arg5);
  }
  virtual Closure<R(Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg2_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R(Arg4, Arg5)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg2_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R(Arg4, Arg5)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg2_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R(Arg4, Arg5)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5)>(NewPermanentClosure(function, pa1, pa2,
      pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg2_Bind3 : public Closure<R(Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg2_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg2_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4, arg5);
  }
  virtual Closure<R(Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg2_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
Closure<R(Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg2_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
Closure<R(Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg2_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename PreArg3, typename F>
ClosureFunc<R(Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg2_Bind4 : public Closure<R(Arg5, Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg2_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6);
  }
  virtual Closure<R(Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg2_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg2_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg2_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctionClosure_Arg2_Bind4 : public Closure<R(Arg5, Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg2_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6);
  }
  virtual Closure<R(Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg2_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg2_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg2_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctorClosure_Arg2_Bind4 : public Closure<R(Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg2_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg2_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6);
  }
  virtual Closure<R(Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg2_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg2_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg2_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R(Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class MethodClosure_Arg2_Bind5 : public Closure<R(Arg6, Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg2_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7);
  }
  virtual Closure<R(Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg2_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg2_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg2_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg2_Bind5 : public Closure<R(Arg6, Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg2_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7);
  }
  virtual Closure<R(Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg2_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg2_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
      pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg2_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
      pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R(Arg6, Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg2_Bind5 : public Closure<R(Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg2_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg2_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7);
  }
  virtual Closure<R(Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg2_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R(Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg2_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R(Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg2_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
ClosureFunc<R(Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg2_Bind6 : public Closure<R(Arg7, Arg8)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8);
  MethodClosure_Arg2_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg2_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7,
        arg8);
  }
  virtual Closure<R(Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg2_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg2_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg2_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8)>(NewPermanentClosure(object, method, pa1,
      pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctionClosure_Arg2_Bind6 : public Closure<R(Arg7, Arg8)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
  FunctionClosure_Arg2_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg2_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8);
  }
  virtual Closure<R(Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg2_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg2_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg2_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8)>(NewPermanentClosure(function, pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctorClosure_Arg2_Bind6 : public Closure<R(Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg2_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg2_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg2_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8);
  }
  virtual Closure<R(Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg2_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg2_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg2_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R(Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8)>(NewPermanentClosure<R, Arg1, Arg2, Arg3,
      Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3 >
class MethodClosure_Arg3_Bind0 : public Closure<R(Arg1, Arg2, Arg3)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3);
  MethodClosure_Arg3_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3);
  }
  virtual Closure<R(Arg1, Arg2, Arg3)>* Clone() {
    return new MethodClosure_Arg3_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R(Arg1, Arg2, Arg3)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_Arg3_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
Closure<R(Arg1, Arg2, Arg3)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return new MethodClosure_Arg3_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3>
ClosureFunc<R(Arg1, Arg2, Arg3)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_Arg3_Bind0 : public Closure<R(Arg1, Arg2, Arg3)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3);
  FunctionClosure_Arg3_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3);
  }
  virtual Closure<R(Arg1, Arg2, Arg3)>* Clone() {
    return new FunctionClosure_Arg3_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R(Arg1, Arg2, Arg3)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_Arg3_Bind0<false, R, Arg1, Arg2, Arg3>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R(Arg1, Arg2, Arg3)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3)) {
  return new FunctionClosure_Arg3_Bind0<true, R, Arg1, Arg2, Arg3>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3>
ClosureFunc<R(Arg1, Arg2, Arg3)>
BindClosure(R(*function)(Arg1, Arg2, Arg3)) {
  return ClosureFunc<R(Arg1, Arg2, Arg3)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3>
class FunctorClosure_Arg3_Bind0 : public Closure<R(Arg1, Arg2, Arg3)> {
public:
  explicit FunctorClosure_Arg3_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg3_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3);
  }
  virtual Closure<R(Arg1, Arg2, Arg3)>* Clone() {
    return new FunctorClosure_Arg3_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
Closure<R(Arg1, Arg2, Arg3)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg3_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
Closure<R(Arg1, Arg2, Arg3)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg3_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3, typename F>
ClosureFunc<R(Arg1, Arg2, Arg3)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1, Arg2, Arg3)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 , typename PreArg1>
class MethodClosure_Arg3_Bind1 : public Closure<R(Arg2, Arg3, Arg4)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
  MethodClosure_Arg3_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg2, Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg3_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1) {
  return new MethodClosure_Arg3_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4), PreArg1 pa1) {
  return new MethodClosure_Arg3_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
    PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4)>(NewPermanentClosure(object, method,
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1>
class FunctionClosure_Arg3_Bind1 : public Closure<R(Arg2, Arg3, Arg4)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4);
  FunctionClosure_Arg3_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind1> self_deleter(this);
    return function_(pa_1_, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg2, Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg3_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return new FunctionClosure_Arg3_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return new FunctionClosure_Arg3_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename PreArg1>
class FunctorClosure_Arg3_Bind1 : public Closure<R(Arg2, Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg3_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg3_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg2, Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg3_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg3_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg3_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename PreArg1, typename F>
ClosureFunc<R(Arg2, Arg3, Arg4)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg3_Bind2 : public Closure<R(Arg3, Arg4, Arg5)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg3_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg3_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg3_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg3_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5)>(NewPermanentClosure(object, method,
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg3_Bind2 : public Closure<R(Arg3, Arg4, Arg5)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg3_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg3_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg3_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg3_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5)>(NewPermanentClosure(function, pa1,
      pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg3_Bind2 : public Closure<R(Arg3, Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg3_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg3_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg3_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
Closure<R(Arg3, Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg3_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
Closure<R(Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg3_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
    typename F>
ClosureFunc<R(Arg3, Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2, typename PreArg3>
class MethodClosure_Arg3_Bind3 : public Closure<R(Arg4, Arg5, Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg3_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg3_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg3_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg3_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3>
class FunctionClosure_Arg3_Bind3 : public Closure<R(Arg4, Arg5, Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg3_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg3_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg3_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg3_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6)>(NewPermanentClosure(function, pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
      typename PreArg3>
class FunctorClosure_Arg3_Bind3 : public Closure<R(Arg4, Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg3_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg3_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg3_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg3_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg3_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R(Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg3_Bind4 : public Closure<R(Arg5, Arg6, Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg3_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg3_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R(Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg3_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R(Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg3_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg3_Bind4 : public Closure<R(Arg5, Arg6, Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg3_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg3_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg3_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
      pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg3_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
      pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg3_Bind4 : public Closure<R(Arg5, Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg3_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg3_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg3_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R(Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg3_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R(Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg3_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
ClosureFunc<R(Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class MethodClosure_Arg3_Bind5 : public Closure<R(Arg6, Arg7, Arg8)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8);
  MethodClosure_Arg3_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7,
        arg8);
  }
  virtual Closure<R(Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg3_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new MethodClosure_Arg3_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg3_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class FunctionClosure_Arg3_Bind5 : public Closure<R(Arg6, Arg7, Arg8)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
  FunctionClosure_Arg3_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg3_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7, Arg8)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg3_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function,
      pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7, Arg8)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg3_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function,
      pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class FunctorClosure_Arg3_Bind5 : public Closure<R(Arg6, Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg3_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg3_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg3_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg3_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg3_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename F>
ClosureFunc<R(Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg3_Bind6 : public Closure<R(Arg7, Arg8, Arg9)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9);
  MethodClosure_Arg3_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg3_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7,
        arg8, arg9);
  }
  virtual Closure<R(Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg3_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R(Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg3_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R(Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg3_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9)>(NewPermanentClosure(object, method,
      pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg3_Bind6 : public Closure<R(Arg7, Arg8, Arg9)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
  FunctionClosure_Arg3_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg3_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8,
        arg9);
  }
  virtual Closure<R(Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg3_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg3_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg3_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9)>(NewPermanentClosure(function, pa1,
      pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg3_Bind6 : public Closure<R(Arg7, Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg3_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg3_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg3_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg3_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg3_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg3_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R(Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9)>(NewPermanentClosure<R, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4,
      pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4 >
class MethodClosure_Arg4_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
  MethodClosure_Arg4_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new MethodClosure_Arg4_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return new MethodClosure_Arg4_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4)) {
  return new MethodClosure_Arg4_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure(object,
      method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctionClosure_Arg4_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4);
  FunctionClosure_Arg4_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new FunctionClosure_Arg4_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_Arg4_Bind0<false, R, Arg1, Arg2, Arg3,
      Arg4>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4)) {
  return new FunctionClosure_Arg4_Bind0<true, R, Arg1, Arg2, Arg3,
      Arg4>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4)) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctorClosure_Arg4_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4)> {
public:
  explicit FunctorClosure_Arg4_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg4_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4)>* Clone() {
    return new FunctorClosure_Arg4_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg4_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg4_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename F>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 , typename PreArg1>
class MethodClosure_Arg4_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg4_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg4_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1) {
  return new MethodClosure_Arg4_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5), PreArg1 pa1) {
  return new MethodClosure_Arg4_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5,
    typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure(object,
      method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1>
class FunctionClosure_Arg4_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg4_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind1> self_deleter(this);
    return function_(pa_1_, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg4_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return new FunctionClosure_Arg4_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return new FunctionClosure_Arg4_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure(function,
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename PreArg1>
class FunctorClosure_Arg4_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5)> {
public:
  explicit FunctorClosure_Arg4_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg4_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg4_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg4_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg4_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename PreArg1, typename F>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
      typename PreArg2>
class MethodClosure_Arg4_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg4_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg4_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg4_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg4_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure(object,
      method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg4_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg4_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg4_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg4_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg4_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
    PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure(function,
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1, typename PreArg2>
class FunctorClosure_Arg4_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg4_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg4_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg4_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg4_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg4_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
    typename PreArg2, typename F>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(std::forward<F>(functor),
      pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg4_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg4_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg4_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg4_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg4_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctionClosure_Arg4_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg4_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg4_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg4_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg4_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure(function,
      pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2, typename PreArg3>
class FunctorClosure_Arg4_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg4_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg4_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg4_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg4_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg4_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class MethodClosure_Arg4_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8);
  MethodClosure_Arg4_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7,
        arg8);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg4_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg4_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg4_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg4_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
  FunctionClosure_Arg4_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg4_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg4_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
      pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg4_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
      pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctorClosure_Arg4_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg4_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg4_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg4_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg4_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg4_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename F>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg4_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9);
  MethodClosure_Arg4_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7,
        arg8, arg9);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg4_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg4_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg4_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctionClosure_Arg4_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
  FunctionClosure_Arg4_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg4_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg4_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg4_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5>
class FunctorClosure_Arg4_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg4_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg4_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg4_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg4_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg4_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4,
      pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class MethodClosure_Arg4_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10);
  MethodClosure_Arg4_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg4_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7,
        arg8, arg9, arg10);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg4_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg4_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg4_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure(object,
      method, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg4_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
  FunctionClosure_Arg4_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg4_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8,
        arg9, arg10);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg4_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return new FunctionClosure_Arg4_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg4_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
    PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure(function,
      pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctorClosure_Arg4_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10)> {
public:
  explicit FunctorClosure_Arg4_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg4_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg4_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg4_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg4_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg4_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6,
    typename F>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure<R, Arg1,
      Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5 >
class MethodClosure_Arg5_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  MethodClosure_Arg5_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new MethodClosure_Arg5_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5)) {
  return new MethodClosure_Arg5_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5)) {
  return new MethodClosure_Arg5_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4,
      Arg5)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5>
class FunctionClosure_Arg5_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
  FunctionClosure_Arg5_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctionClosure_Arg5_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_Arg5_Bind0<false, R, Arg1, Arg2, Arg3, Arg4,
      Arg5>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return new FunctionClosure_Arg5_Bind0<true, R, Arg1, Arg2, Arg3, Arg4,
      Arg5>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4,
      Arg5)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5>
class FunctorClosure_Arg5_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4,
    Arg5)> {
public:
  explicit FunctorClosure_Arg5_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg5_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4, arg5);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>* Clone() {
    return new FunctorClosure_Arg5_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg5_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg5_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename F>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 , typename PreArg1>
class MethodClosure_Arg5_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg5_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg5_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6), PreArg1 pa1) {
  return new MethodClosure_Arg5_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6), PreArg1 pa1) {
  return new MethodClosure_Arg5_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1>
class FunctionClosure_Arg5_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg5_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind1> self_deleter(this);
    return function_(pa_1_, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg5_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1) {
  return new FunctionClosure_Arg5_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
    PreArg1 pa1) {
  return new FunctionClosure_Arg5_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename PreArg1>
class FunctorClosure_Arg5_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
public:
  explicit FunctorClosure_Arg5_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg5_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg5_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg5_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg5_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename PreArg1, typename F>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(std::forward<F>(functor),
      pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1, typename PreArg2>
class MethodClosure_Arg5_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg5_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg5_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg5_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg5_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2>
class FunctionClosure_Arg5_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg5_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg5_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7), PreArg1 pa1,
    PreArg2 pa2) {
  return new FunctionClosure_Arg5_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg5_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
      typename PreArg2>
class FunctorClosure_Arg5_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
public:
  explicit FunctorClosure_Arg5_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg5_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg5_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg5_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg5_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1,
      PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg5_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8);
  MethodClosure_Arg5_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7,
        arg8);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg5_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg5_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg5_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
    typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg5_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
  FunctionClosure_Arg5_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg5_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg5_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg5_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg5_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
public:
  explicit FunctorClosure_Arg5_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg5_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg5_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg5_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg5_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename PreArg3, typename F>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2,
      PreArg3>(std::forward<F>(functor), pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class MethodClosure_Arg5_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9);
  MethodClosure_Arg5_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7,
        arg8, arg9);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg5_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg5_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg5_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
      PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctionClosure_Arg5_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
  FunctionClosure_Arg5_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg5_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg5_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4>(function,
      pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg5_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4>(function,
      pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4>
class FunctorClosure_Arg5_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
public:
  explicit FunctorClosure_Arg5_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg5_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg5_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg5_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg5_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename F>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3, PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg5_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10);
  MethodClosure_Arg5_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7,
        arg8, arg9, arg10);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg5_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg5_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg5_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg5_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
  FunctionClosure_Arg5_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg5_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg5_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg5_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg5_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
public:
  explicit FunctorClosure_Arg5_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg5_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg5_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg5_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg5_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename F>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5>(std::forward<F>(functor), pa1, pa2,
      pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class MethodClosure_Arg5_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11);
  MethodClosure_Arg5_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg5_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7,
        arg8, arg9, arg10, arg11);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new MethodClosure_Arg5_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg5_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg5_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctionClosure_Arg5_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11);
  FunctionClosure_Arg5_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg5_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8,
        arg9, arg10, arg11);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctionClosure_Arg5_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg5_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg5_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
      typename PreArg6>
class FunctorClosure_Arg5_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11)> {
public:
  explicit FunctorClosure_Arg5_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg5_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg5_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctorClosure_Arg5_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg5_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg5_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename PreArg6, typename F>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11)>(NewPermanentClosure<R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
      PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6 >
class MethodClosure_Arg6_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  MethodClosure_Arg6_Bind0(Class *object, MethodType method):
    object_(object), method_(method) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind0> self_deleter(this);
    return (object_->*method_)(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new MethodClosure_Arg6_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6)) {
  return new MethodClosure_Arg6_Bind0<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6)) {
  return new MethodClosure_Arg6_Bind0<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6>(
    object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)) {
  return ClosureFunc<R (Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(object, method));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6>
class FunctionClosure_Arg6_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
  FunctionClosure_Arg6_Bind0(FunctionType function):
    function_(function) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind0> self_deleter(this);
    return function_(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctionClosure_Arg6_Bind0(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_Arg6_Bind0<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return new FunctionClosure_Arg6_Bind0<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure(function));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6>
class FunctorClosure_Arg6_Bind0 : public Closure<R(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6)> {
public:
  explicit FunctorClosure_Arg6_Bind0(const F& functor)
    : functor_(functor) {}
  explicit FunctorClosure_Arg6_Bind0(F&& functor)
    : functor_(std::move(functor)) {}
  virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
      Arg6 arg6) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind0> self_deleter(this);
    return functor_(arg1, arg2, arg3, arg4, arg5, arg6);
  }
  virtual Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>* Clone() {
    return new FunctorClosure_Arg6_Bind0(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(F&& functor) {
  return new FunctorClosure_Arg6_Bind0<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
Closure<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(F&& functor) {
  return new FunctorClosure_Arg6_Bind0<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(
    std::forward<F>(functor));
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename F>
ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>
BindClosure(F&& functor) {
  return ClosureFunc<R(Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6>(std::forward<F>(functor)));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
      typename PreArg1>
class MethodClosure_Arg6_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6,
    Arg7)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  MethodClosure_Arg6_Bind1(Class *object, MethodType method, PreArg1 pa1):
    object_(object), method_(method), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind1> self_deleter(this);
    return (object_->*method_)(pa_1_, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new MethodClosure_Arg6_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7), PreArg1 pa1) {
  return new MethodClosure_Arg6_Bind1<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1) {
  return new MethodClosure_Arg6_Bind1<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7), PreArg1 pa1) {
  return ClosureFunc<R (Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(object, method, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1>
class FunctionClosure_Arg6_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
  FunctionClosure_Arg6_Bind1(FunctionType function, PreArg1 pa1):
    function_(function), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind1> self_deleter(this);
    return function_(pa_1_, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctionClosure_Arg6_Bind1(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return new FunctionClosure_Arg6_Bind1<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return new FunctionClosure_Arg6_Bind1<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
    PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure(function, pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename PreArg1>
class FunctorClosure_Arg6_Bind1 : public Closure<R(Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7)> {
public:
  explicit FunctorClosure_Arg6_Bind1(const F& functor, PreArg1 pa1)
    : functor_(functor), pa_1_(pa1) {}
  explicit FunctorClosure_Arg6_Bind1(F&& functor, PreArg1 pa1)
    : functor_(std::move(functor)), pa_1_(pa1) {}
  virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
      Arg7 arg7) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind1> self_deleter(this);
    return functor_(pa_1_, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  virtual Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>* Clone() {
    return new FunctorClosure_Arg6_Bind1(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg6_Bind1<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
Closure<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(F&& functor, PreArg1 pa1) {
  return new FunctorClosure_Arg6_Bind1<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
    std::forward<F>(functor), pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7,
    typename PreArg1, typename F>
ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>
BindClosure(F&& functor, PreArg1 pa1) {
  return ClosureFunc<R(Arg2, Arg3, Arg4, Arg5, Arg6,
      Arg7)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      PreArg1>(std::forward<F>(functor), pa1));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg6_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8);
  MethodClosure_Arg6_Bind2(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind2> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7,
        arg8);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new MethodClosure_Arg6_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg6_Bind2<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new MethodClosure_Arg6_Bind2<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R (Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(object, method, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2>
class FunctionClosure_Arg6_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6,
    Arg7, Arg8)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
  FunctionClosure_Arg6_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
    function_(function), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind2> self_deleter(this);
    return function_(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctionClosure_Arg6_Bind2(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg6_Bind2<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8), PreArg1 pa1, PreArg2 pa2) {
  return new FunctionClosure_Arg6_Bind2<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
    PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure(function, pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename PreArg1, typename PreArg2>
class FunctorClosure_Arg6_Bind2 : public Closure<R(Arg3, Arg4, Arg5, Arg6,
    Arg7, Arg8)> {
public:
  explicit FunctorClosure_Arg6_Bind2(const F& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2) {}
  explicit FunctorClosure_Arg6_Bind2(F&& functor, PreArg1 pa1, PreArg2 pa2)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2) {}
  virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
      Arg8 arg8) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind2> self_deleter(this);
    return functor_(pa_1_, pa_2_, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  virtual Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>* Clone() {
    return new FunctorClosure_Arg6_Bind2(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg6_Bind2<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
Closure<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return new FunctorClosure_Arg6_Bind2<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
    std::forward<F>(functor), pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename PreArg1, typename PreArg2, typename F>
ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2) {
  return ClosureFunc<R(Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, PreArg1, PreArg2>(std::forward<F>(functor), pa1, pa2));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
      typename PreArg3>
class MethodClosure_Arg6_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8,
    Arg9)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9);
  MethodClosure_Arg6_Bind3(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind3> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7,
        arg8, arg9);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new MethodClosure_Arg6_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new MethodClosure_Arg6_Bind3<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3) {
  return new MethodClosure_Arg6_Bind3<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(
    object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
    typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R (Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(object, method, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg6_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9);
  FunctionClosure_Arg6_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind3> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctionClosure_Arg6_Bind3(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg6_Bind3<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
      pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctionClosure_Arg6_Bind3<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
      pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure(function, pa1, pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctorClosure_Arg6_Bind3 : public Closure<R(Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9)> {
public:
  explicit FunctorClosure_Arg6_Bind3(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  explicit FunctorClosure_Arg6_Bind3(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3) {}
  virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
      Arg9 arg9) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind3> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  virtual Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>* Clone() {
    return new FunctorClosure_Arg6_Bind3(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg6_Bind3<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
Closure<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return new FunctorClosure_Arg6_Bind3<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
      PreArg3>(
    std::forward<F>(functor), pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
    typename F>
ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
  return ClosureFunc<R(Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, PreArg1, PreArg2, PreArg3>(std::forward<F>(functor), pa1,
      pa2, pa3));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg6_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10);
  MethodClosure_Arg6_Bind4(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind4> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7,
        arg8, arg9, arg10);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new MethodClosure_Arg6_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new MethodClosure_Arg6_Bind4<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return new MethodClosure_Arg6_Bind4<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2,
      PreArg3, PreArg4>(
    object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R (Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctionClosure_Arg6_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8,
    Arg9, Arg10)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10);
  FunctionClosure_Arg6_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind4> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctionClosure_Arg6_Bind4(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg6_Bind4<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctionClosure_Arg6_Bind4<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
      typename PreArg3, typename PreArg4>
class FunctorClosure_Arg6_Bind4 : public Closure<R(Arg5, Arg6, Arg7, Arg8,
    Arg9, Arg10)> {
public:
  explicit FunctorClosure_Arg6_Bind4(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4) {}
  explicit FunctorClosure_Arg6_Bind4(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4) {}
  virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
      Arg10 arg10) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind4> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, arg5, arg6, arg7, arg8, arg9,
        arg10);
  }
  virtual Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>* Clone() {
    return new FunctorClosure_Arg6_Bind4(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return new FunctorClosure_Arg6_Bind4<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
Closure<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4) {
  return new FunctorClosure_Arg6_Bind4<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
      PreArg2, PreArg3, PreArg4>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename F>
ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
  return ClosureFunc<R(Arg5, Arg6, Arg7, Arg8, Arg9,
      Arg10)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
      PreArg4>(std::forward<F>(functor), pa1, pa2, pa3, pa4));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5>
class MethodClosure_Arg6_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11);
  MethodClosure_Arg6_Bind5(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind5> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7,
        arg8, arg9, arg10, arg11);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new MethodClosure_Arg6_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg6_Bind5<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return new MethodClosure_Arg6_Bind5<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2,
      PreArg3, PreArg4, PreArg5>(
    object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
    typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
  return ClosureFunc<R (Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg6_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11);
  FunctionClosure_Arg6_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind5> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctionClosure_Arg6_Bind5(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctionClosure_Arg6_Bind5<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctionClosure_Arg6_Bind5<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
      typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctorClosure_Arg6_Bind5 : public Closure<R(Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11)> {
public:
  explicit FunctorClosure_Arg6_Bind5(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5) {}
  explicit FunctorClosure_Arg6_Bind5(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5) {}
  virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
      Arg11 arg11) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind5> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, arg6, arg7, arg8, arg9,
        arg10, arg11);
  }
  virtual Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>* Clone() {
    return new FunctorClosure_Arg6_Bind5(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return new FunctorClosure_Arg6_Bind5<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
Closure<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5) {
  return new FunctorClosure_Arg6_Bind5<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
    typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
    typename F>
ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5) {
  return ClosureFunc<R(Arg6, Arg7, Arg8, Arg9, Arg10,
      Arg11)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5));
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R,
  typename Class,
  typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
      typename Arg4, typename Arg5, typename Arg6, typename Arg7,
      typename Arg8, typename Arg9, typename Arg10, typename Arg11,
      typename Arg12 , typename PreArg1, typename PreArg2, typename PreArg3,
      typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg6_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
 public:
  typedef R(MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11, Arg12);
  MethodClosure_Arg6_Bind6(Class *object, MethodType method, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    object_(object), method_(method), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        MethodClosure_Arg6_Bind6> self_deleter(this);
    return (object_->*method_)(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7,
        arg8, arg9, arg10, arg11, arg12);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new MethodClosure_Arg6_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  Class* object_;
  MethodType method_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4, Arg5,
    Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2,
    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg6_Bind6<false, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3,
    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new MethodClosure_Arg6_Bind6<true, R, Class, MethodClass, Arg1, Arg2,
      Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1,
      PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
    typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
    typename Arg7, typename Arg8, typename Arg9, typename Arg10,
    typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
    typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(Class *object, R(MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
    Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R (Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure(object, method, pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename Arg12,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctionClosure_Arg6_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
 public:
  typedef R(*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
      Arg9, Arg10, Arg11, Arg12);
  FunctionClosure_Arg6_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
    function_(function), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        FunctionClosure_Arg6_Bind6> self_deleter(this);
    return function_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8,
        arg9, arg10, arg11, arg12);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new FunctionClosure_Arg6_Bind6(*this);
  }
  virtual bool IsPermanent() const { return Permanent; }
 private:
  FunctionType function_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg6_Bind6<false, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
    Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctionClosure_Arg6_Bind6<true, R, Arg1, Arg2, Arg3, Arg4, Arg5,
      Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3,
      PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(R(*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
    Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure(function, pa1, pa2, pa3, pa4, pa5, pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Functor closures
/////////////////////////////////////////////////////////////////////////////

template <
  bool Permanent, typename F,
  typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
      typename Arg5, typename Arg6, typename Arg7, typename Arg8,
      typename Arg9, typename Arg10, typename Arg11, typename Arg12,
      typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
      typename PreArg5, typename PreArg6>
class FunctorClosure_Arg6_Bind6 : public Closure<R(Arg7, Arg8, Arg9, Arg10,
    Arg11, Arg12)> {
public:
  explicit FunctorClosure_Arg6_Bind6(const F& functor, PreArg1 pa1,
      PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(functor), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3), pa_4_(pa4),
        pa_5_(pa5), pa_6_(pa6) {}
  explicit FunctorClosure_Arg6_Bind6(F&& functor, PreArg1 pa1, PreArg2 pa2,
      PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6)
    : functor_(std::move(functor)), pa_1_(pa1), pa_2_(pa2), pa_3_(pa3),
        pa_4_(pa4), pa_5_(pa5), pa_6_(pa6) {}
  virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
      Arg12 arg12) {
    ConditionalAutoDeleter<!Permanent,
        FunctorClosure_Arg6_Bind6> self_deleter(this);
    return functor_(pa_1_, pa_2_, pa_3_, pa_4_, pa_5_, pa_6_, arg7, arg8, arg9,
        arg10, arg11, arg12);
  }
  virtual Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>* Clone() {
    return new FunctorClosure_Arg6_Bind6(*this);
  }
  bool IsPermanent() const { return Permanent; }
private:
  F functor_;
  PreArg1 pa_1_;
  PreArg2 pa_2_;
  PreArg3 pa_3_;
  PreArg4 pa_4_;
  PreArg5 pa_5_;
  PreArg6 pa_6_;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg6_Bind6<false, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
Closure<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
  return new FunctorClosure_Arg6_Bind6<true, typename std::decay<F>::type, R,
      Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
    std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
    typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
    typename Arg9, typename Arg10, typename Arg11, typename Arg12,
    typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
    typename PreArg5, typename PreArg6, typename F>
ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>
BindClosure(F&& functor, PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
    PreArg5 pa5, PreArg6 pa6) {
  return ClosureFunc<R(Arg7, Arg8, Arg9, Arg10, Arg11,
      Arg12)>(NewPermanentClosure<R, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
      Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2, PreArg3, PreArg4,
      PreArg5, PreArg6>(std::forward<F>(functor), pa1, pa2, pa3, pa4, pa5,
      pa6));
}

/////////////////////////////////////////////////////////////////////////////
// Helper function for 0-Args-Functor
/////////////////////////////////////////////////////////////////////////////

template <typename F>
auto NewClosure(F&& functor) -> Closure<decltype(functor())()>* {
  return new FunctorClosure_Arg0_Bind0<false, typename std::decay<F>::type,
      decltype(functor())>(std::forward<F>(functor));
}

template <typename F>
auto NewPermanentClosure(F&& functor) -> Closure<decltype(functor())()>* {
  return new FunctorClosure_Arg0_Bind0<true, typename std::decay<F>::type,
      decltype(functor())>(std::forward<F>(functor));
}

template <typename F>
auto BindClosure(F&& functor) -> ClosureFunc<decltype(functor())()> {
  return

      ClosureFunc<decltype(functor())()>(NewPermanentClosure(std::forward<F>(functor)));
}

}  // namespace ccb

#endif  // CCBASE_CLOSURE_H_
